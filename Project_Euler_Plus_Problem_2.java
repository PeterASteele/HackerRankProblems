import java.util.Scanner;
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Project_Euler_Plus_Problem_2 {
	/*
	 * Problem Statement:
	 * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
1,2,3,5,8,13,21,34,55,89,⋯
By considering the terms in the Fibonacci sequence whose values do not exceed N, find the sum of the even-valued terms.

Input Format 
First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N.

Output Format 
Print the required answer for each test case.

Constraints 
1≤T≤10^5 
10≤N≤4×10^16
	 */
	public static void main(String[] args) {
		Scanner stdin = new Scanner(System.in);
		
		//Parse number of test cases.
		int numberOfCases = Integer.parseInt(stdin.nextLine());
		
		//Create an array of Fibonacci up to 4x10^16. We don't know exactly how large to make this array, but we can safely establish that it is smaller than 2 * log2(4x10^16) by using inequalities.
		// 1 2 3 5 8 13 .... is guaranteed to be greater than the following sequence, and therefore will reach 4x10^16 faster.
		// 1 1 2 2 4 4 8 8... (Proof; Term1top = Term1bottom, Term2top>Term2bottom. Term 1 + Term 2 > Term1 * 2. Continue this process, all upper terms are greater or equal to lower terms.
		//Therefore, 2 * log2(4x10^16) is large enough.
		//10^3 < 2^10, so 2 * log2(2^58) > 2 * log2(4x10^16), and our array can safely be size 116.
		
		BigInteger[] fibonacci = new BigInteger[116];
		BigInteger endpoint = new BigInteger("40000000000000000");
		BigInteger number1 = new BigInteger("1");
		BigInteger number2 = new BigInteger("2");
		fibonacci[0] = number1;
		fibonacci[1] = number2;
		int index = 2;
		while (number2.compareTo(endpoint) < 0){ //We'll go two at a time for simplicity.
			number1 = number2.add(number1);
			fibonacci[index] = number1;
			index++;
			number2 = number1.add(number2);
			fibonacci[index] = number2;
			index++;	
		}
		
		
		
		//We're safe! The array only needed to be 82 integers long.
		//Now that we have made this array, the rest of the problem is pretty easy. Our next step is to make another array, that contains the sum of the even numbered values up to a given index.
		BigInteger[] fibonacciEvenSums = new BigInteger[116];
	
		BigInteger sum  = new BigInteger("" + 0);
		int index2 = 0;
		for(int a = 0; a < 82; a++){
			if (fibonacci[a].mod(new BigInteger(2 + "")).compareTo(new BigInteger(0 + "")) < 1){
				sum = sum.add(fibonacci[a]);
			}
			
			fibonacciEvenSums[a] = sum;
			System.out.println(fibonacci[a] + "    " + fibonacciEvenSums[a]);
			index2++;			
		}	
		
		
		
		
		
		// Now, it's a matter of taking the input, finding which is the closest fibonacci element without going over, and printing the desired result.
		// Note: This would be slightly more efficient with a binary search; There is only 80 elements however, so there is not a massive benefit of doing so.
		int index3;
		BigInteger input;
		for(int a = 0; a < numberOfCases; a++){
			index3 = 0;
			input = new BigInteger(stdin.nextLine());
			while(input.compareTo(fibonacci[index3]) >= 0){
				index3++;
			}
			System.out.println(fibonacciEvenSums[index3-1]);	
		}
		
		
		
	}

}
