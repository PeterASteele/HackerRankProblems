import java.util.Scanner;

/*
 * The sequence of triangle numbers is generated by adding the natural numbers. So the 7'th triangle number would be 1+2+3+4+5+6+7=28. The first ten terms would be:

1,3,6,10,15,21,28,36,45,55,...

Let us list the factors of the first seven triangle numbers:

1:1 
3:1,3 
6:1,2,3,6 
10:1,2,5,10 
15:1,3,5,15 
21:1,3,7,21 
28:1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over N divisors?

Input 
First line T, the number of testcases. Each testcase consists of N in one line.

Output 
For each testcase, print the required answer in one line.

Constraints 
1≤T≤10 
1≤N≤103
 */
public class Project_Euler_Plus_Problem12 {
	public static void main(String[] args) {
		Scanner stdin = new Scanner(System.in);
		int numberOfCases = Integer.parseInt(stdin.nextLine());
		//Parse the first line of input, the number of cases.
		
		int[] preProcessing = preProcess();
		//Pre-process data
		
		String input;
		for (int a = 0; a < numberOfCases; a++) {
			input = stdin.nextLine();
			int inputData = Integer.parseInt(input);
			System.out.println(preProcessing[inputData+1]);
			
		}
	}
	/*
	 * Calculates the number of divisors for a given number.
	 * Complexity goes up with the squareroot of the input number.
	 */
	public static int getNumDivisors(int number){
		int count = 0;
		for(int a = 1; a < Math.sqrt(number); a++){
			if (number%a == 0){
				count = count + 2; 
				//Each factor we find mean that two factors exist, a and number/a, 
				//with the exception of when a = number/a, which is the squareroot case.
			}
		}
		if (Math.sqrt(number)%1 == 0){
			count++; //Compensating for the square root case
		}
		return count;
	}
	/*
	 * pre-processes the data and populates an array with the lowest triangular number with n factors, where n is the index of the array.
	 */
	public static int[] preProcess(){
		int[] preProcessing = new int[1002];
		for(int a = 0; a < preProcessing.length; a++){
			preProcessing[a] = 0;
		}
		
		
		for(int a = 0; a < preProcessing.length; a++){
			int triangular = 0;
			int count = 1;
			int temp = 0;
			while(preProcessing[1001] == 0){
			 	triangular += count;
			 	count++;
			 	temp = getNumDivisors(triangular);
			 	if (temp > 1001){
			 		temp = 1001;
			 	}
			 	if (preProcessing[temp] == 0){
			 		for(int b = 0; b < temp; b++){
						if (triangular < preProcessing[b] || preProcessing[b] == 0){
							preProcessing[b] = triangular;
						}
					}
			 		preProcessing[temp] = triangular;
			 	}
			}
		}
		return preProcessing;
	}
}
